#include <iostream>
using namespace std;



//------------------------------------------------------------------------------
//	템플릿 리스트 클래스
//	
//	:이터레이터와 합성관계
//	:이터레이터 연산자 오버로딩 지원
//------------------------------------------------------------------------------
template <typename T>
class CList
{
public:

	//------------------------------------------------------------------------------
	//	노드 구조체
	//	
	//	:리스트 각 노드
	//	:이터레이터와 합성관계
	//------------------------------------------------------------------------------
	struct Node
	{
		//------------------------------------------------------------------------------
		//	주의
		//
		//	:T _data를 T *_data *형식으로 하지 말 것.
		//	:만일 *형식으로 설정하고 싶으면 차라리 클래스 생성시 템플릿 인자를 *로 할 것.
		//
		//	:이유
		//	:	변수 시에는 그냥 저장하면 _data에 저장하면 됨
		//	:	크기가 큰 클래스는 T타입을 포인터로 받으면 됨.
		//------------------------------------------------------------------------------
		T _data;
		Node *_Prev;
		Node *_Next;
	};


	//------------------------------------------------------------------------------
	//	이터레이터 클래스
	//
	//	:노드 구조체와 합성관계	
	//	:노드 구조체에 여러 오버로딩 지원 가능
	//	:리스트 요소 순회 시 현재 방문 중인 노드를 클래스 바깥으로 빼서 보관 할 수 있다. (이는 1개 이상 가능)
	//	:기존 방식인 클래스 내 하나의 현재 방문 중인 노드 포인터로는 하나의 현재 방문 요소만 저장 가능. (이는 1개만 가능)
	//------------------------------------------------------------------------------
	class iterator
	{

	
	private:
		
		//------------------------------------------------------------------------------
		//	이터레이터 데이터 값
		//------------------------------------------------------------------------------
		Node * _node;


		Node * GetNode()
		{
			return _node;
		}

		//------------------------------------------------------------------------------
		//	프랜드 선언
		//
		//	:합성 관계
		//------------------------------------------------------------------------------
		friend class CList;

	public:

		//------------------------------------------------------------------------------
		//	생성자
		//------------------------------------------------------------------------------
		iterator(Node *node);


		//------------------------------------------------------------------------------
		//	후위 증가 연산자
		//------------------------------------------------------------------------------
		iterator operator ++(int)
		{
			//반환 리터 선언 및 초기화
			iterator out_iter(_node);

			//현재 노드를 다음 노드로 이동
			_node = _node->_Next;

			return out_iter;
		}
		
		//------------------------------------------------------------------------------
		//	후위 감소 연산자
		//------------------------------------------------------------------------------
		iterator operator --(int)
		{

			//반환 리터 선언 및 초기화
			iterator out_iter(_node);

			//현재 노드를 다음 노드로 이동
			_node = _node->_Prev;

			return out_iter;
		}


		//------------------------------------------------------------------------------
		//	전위 증가 연산자
		//------------------------------------------------------------------------------
		iterator operator ++()
		{
			//현재 이터레이터가 테일 더미 인 경우
			if (_node->_Next == NULL)
			{
				return *this;
			}
			//현재 노드를 다음 노드로 이동
			else
				_node = _node->_Next;

			return *this;
		}

		//------------------------------------------------------------------------------
		//	전위 감소 연산자
		//------------------------------------------------------------------------------
		iterator operator --()
		{
			//현재 이터레이터가 헤드 더미 인 경우
			if (_node->_Prev == NULL)
			{
				return *this;
			}
			//현재 노드를 다음 노드로 이동
			else 
				_node = _node->_Prev;

			return *this;
		}


		//------------------------------------------------------------------------------
		//	* 연산자
		//
		//	:이터레이터 데이터 값 반환 
		//------------------------------------------------------------------------------
		T& operator *()
		{
			//현재 노드의 데이터를 뽑음
			return _node->_data;
		}


		//------------------------------------------------------------------------------
		//	== 비교 연산자 
		//------------------------------------------------------------------------------
		bool operator ==(const iterator target)
		{
			return (_node == target._node);
		}


		//------------------------------------------------------------------------------
		//	!= 비교 연산자2 
		//------------------------------------------------------------------------------
		bool operator !=(const iterator target)
		{
			return !(*this == target);
		}


		//------------------------------------------------------------------------------
		//	= 대입 연산자
		//------------------------------------------------------------------------------
		iterator& operator =(const iterator& target)
		{
			_node = target._node;
			return *this;
		}

	};

public:
	CList();
	~CList();


	//------------------------------------------------------------------------------
	//	시작 이터레이터 반환
	//
	//	:만일 노드가 존재하지 않으면 헤드 더미 노드 반환
	//	:노드가 1개 이상 존재시 첫 번째 노드 반환
	//------------------------------------------------------------------------------
	iterator begin()
	{
			//노드가 존재하지 않는 경우
			if (true == is_empty())
			{
				iterator new_iter = iterator(&_head);
				return new_iter;
			}
			//요소가 1개 이상 존재하는 경우
			else
			{
				iterator new_iter = iterator(_head._Next);
				return new_iter;
			}

	}


	//------------------------------------------------------------------------------
	//	마지막 이터레이터 반환
	//
	//	:무조건 테일 더미 노드 반환
	//------------------------------------------------------------------------------
	iterator end()
	{
			//반환 이터레이터 선언 및 테일 더미 노드로 초기화
			iterator new_iter = iterator(&_tail);
			return new_iter;
	}


	//------------------------------------------------------------------------------
	//	이터레이터 지우기
	//
	//	:이터레이터 내부 노드 지움
	//	:지운 노드의 다음 노드를 가리키는 이터레이터 반환
	//------------------------------------------------------------------------------
	iterator erase(iterator itor)
	{
		//삭제 노드
		Node *delete_node = itor.GetNode();

		//삭제 노드 이전 노드와 이후 노드 선언
		Node *prev_node = delete_node->_Prev;
		Node *next_node = delete_node->_Next;


		//헤드 더미 또는 테일 더미 여부 검사
		if (prev_node == NULL || next_node == NULL)
		{
			return itor;
		}




		//이전 노드와 이후 노드 간 연결
		prev_node->_Next = next_node;
		next_node->_Prev = prev_node;

		delete(delete_node);

		//반환 이터는 삭제 노드의 다음 노드를 가리킴
		//프렌드 이므로 프라이빗 멤버 _node 접근 가능
		itor._node = next_node;

		//반환
		return itor;

	}


	//------------------------------------------------------------------------------
	//	인터페이스 함수 목록
	//------------------------------------------------------------------------------
	void push_front(T data); //첫 번째 노드로 추가
	void push_back(T data); //마지막 노드로 추가
	void clear();	//모든 노드 삭제
	void DisplayAll();	//모든 노드 출력

	int size() { return _size; };	//사이즈 반환
	bool is_empty();	//빈 여부 체크

	

private:
	int _size = 0;
	Node _head;
	Node _tail;
};





/////////////////////////////////////////////////////////////


//------------------------------------------------------------------------------
//	생성자
//
//	:헤드 더미 노드와 테일 더미 노드 생성 후 연결
//	:두 더미 노드로 인해 삽입 로직이 간단해진다.
//------------------------------------------------------------------------------
template <typename T>
CList<T>::CList()
{

	//헤드 더미 노드 생성 및 초기화
	_head = *( new Node );
	_head._data = -1;
	_head._Prev = NULL;
	_head._Next = NULL;

	//테일 더미 노드 생성 및 초기화
	_tail = *(new Node);
	_tail._data = -1;
	_tail._Prev = NULL;
	_tail._Next = NULL;

	//헤드 더미 노드와 테일 더미 노드 연결
	//아무 요소도 없는 경우
	_head._Next = &(_tail);
	_tail._Prev = &(_head);

	//노드 사이즈 0
	_size = 0;


}


//------------------------------------------------------------------------------
//	삽입 프론트
//
//	:헤드 더미 노드 이후에 새 노드 생성 후 삽입
//------------------------------------------------------------------------------
template <typename T>
void CList<T>::push_front(T data)
{
	//새 삽입 노드 생성
	Node * new_node = new Node();
	new_node->_data = data;
	
	//연결 설정
	_head._Next->_Prev = new_node;
	new_node->_Next = _head._Next;

	new_node->_Prev = &(_head);
	_head._Next = new_node;


	//노드 사이즈 증가
	_size++;

	
}


//------------------------------------------------------------------------------
//	삽입 백
//
//	:테일 더미 노드 이전에 새 노드 생성 후 삽입
//------------------------------------------------------------------------------
template <typename T>
void CList<T>::push_back(T data)
{
	//새 삽입 노드 생성
	Node * new_node = new Node();
	new_node->_data = data;

	//연결 설정
	_tail._Prev->_Next = new_node;
	new_node->_Prev = _tail._Prev;

	_tail._Prev = new_node;
	new_node->_Next = &(_tail);
	

	//노드 사이즈 증가
	_size++;
}



//------------------------------------------------------------------------------
//	화면 출력
//
//	:데이터 타입에 주의 할 것
//------------------------------------------------------------------------------
template <typename T>
void CList<T>:: DisplayAll()
{
	//방문 노드 생성
	//출력 시작 노드 가리킴
	Node * current_node = _head._Next;

	//인덱스 
	int idx = 0;
	//순회 진행 출력
	while (current_node->_Next != NULL)
	{
		cout <<"["<<idx++<<"] "<< current_node->_data << endl;
		current_node = current_node->_Next;
	}

	//노드 사이즈 0
	_size = 0;

	//출력 하지 못한 경우 == 개수가0개인 경우
	if (idx == 0)
		cout << "empty";


}

//------------------------------------------------------------------------------
//	모든 요소 지우기
//------------------------------------------------------------------------------
template <typename T>
void CList<T>::clear()
{
	//방문 노드 생성
	//출력 시작 노드 가리킴
	Node * current_node = _head._Next;

	//커런트 노드 이전 노드 
	Node * prev_node = current_node;
	int idx = 0;
	
	//순회하며 순차적 삭제
	while (current_node->_Next != NULL)
	{
		idx++;
		prev_node = current_node;
		current_node = current_node->_Next;
		delete(prev_node);

	}

	cout << "total delete:" << idx << endl;



	//헤드 더미 노드와 테일 더미 노드 연결
	//아무 요소도 없는 경우
	_head._Next = &(_tail);
	_tail._Prev = &(_head);
	

	


}


//------------------------------------------------------------------------------
//	리스트가 비어있는 여부 체크
//
//	:헤드 더미 노드와 테일 더미 노드는 제외
//------------------------------------------------------------------------------
template <typename T>
bool CList<T>::is_empty()
{
	if (_size == 0)
		return true;
	else
		return false;
}


//------------------------------------------------------------------------------
//	소멸자
//
//	:헤드 더미 노드와 테일 더미 노드는 제외
//------------------------------------------------------------------------------
template <typename T>
CList<T>::~CList()
{
	Node * current_node = _head._Next;
	Node * prev_node = current_node;

	//순회하며 순차적 삭제
	while (!current_node->_Next != NULL)
	{
		prev_node = current_node;
		current_node = current_node->_Next;
		delete(prev_node);
	}

	_size = 0;
}










//------------------------------------------------------------------------------
//
//
//	이터레이터 부분
//
//
//------------------------------------------------------------------------------



//------------------------------------------------------------------------------
//	생성자
//------------------------------------------------------------------------------
template<typename T>
CList<T>::iterator::iterator (Node *node = nullptr)
{
	//인자로 들어온 Node 포인터를 저장
	_node = node;
}

